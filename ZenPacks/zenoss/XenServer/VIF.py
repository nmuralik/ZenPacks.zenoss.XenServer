######################################################################
#
# Copyright (C) Zenoss, Inc. 2013, all rights reserved.
#
# This content is made available according to terms specified in
# License.zenoss under the directory where your Zenoss product is
# installed.
#
######################################################################

import logging
LOG = logging.getLogger('xen.XenServer')

from zope.component import adapts
from zope.interface import implements

from Products.ZenRelations.RelSchema import ToMany, ToManyCont, ToOne
from Products.ZenUtils.Utils import prepId
from Products.Zuul.catalog.paths import DefaultPathReporter, relPath
from Products.Zuul.form import schema
from Products.Zuul.infos import ProxyProperty
from Products.Zuul.utils import ZuulMessageFactory as _t

from ZenPacks.zenoss.XenServer import CLASS_NAME, MODULE_NAME
from ZenPacks.zenoss.XenServer.utils import (
    PooledComponent, IPooledComponentInfo, PooledComponentInfo,
    RelationshipInfoProperty,
    updateToOne,
    id_from_ref,
    )


class VIF(PooledComponent):
    '''
    Model class for VIF (virtual interface.)
    '''

    meta_type = portal_type = 'XenServerVIF'

    xenapi_metrics_ref = None
    macaddress = None
    mac_autogenerated = None
    mtu = None
    allowed_operations = None
    currently_attached = None
    vif_device = None
    ipv4_allowed = None
    ipv6_allowed = None
    locking_mode = None

    _properties = PooledComponent._properties + (
        {'id': 'xenapi_metrics_ref', 'type': 'string', 'mode': 'w'},
        {'id': 'macaddress', 'type': 'string', 'mode': 'w'},
        {'id': 'mac_autogenerated', 'type': 'boolean', 'mode': 'w'},
        {'id': 'mtu', 'type': 'string', 'mode': 'w'},
        {'id': 'allowed_operations', 'type': 'lines', 'mode': 'w'},
        {'id': 'currently_attached', 'type': 'boolean', 'mode': 'w'},
        {'id': 'vif_device', 'type': 'string', 'mode': 'w'},
        {'id': 'ipv4_allowed', 'type': 'lines', 'mode': 'w'},
        {'id': 'ipv6_allowed', 'type': 'lines', 'mode': 'w'},
        {'id': 'locking_mode', 'type': 'string', 'mode': 'w'},
        )

    _relations = PooledComponent._relations + (
        ('vm', ToOne(ToManyCont, MODULE_NAME['VM'], 'vifs')),
        ('network', ToOne(ToMany, MODULE_NAME['Network'], 'vifs')),
        )

    @classmethod
    def objectmap(cls, ref, properties):
        '''
        Return an ObjectMap given XenAPI VIF ref and properties.
        '''
        if 'uuid' not in properties:
            return {
                'compname': 'vms/{}'.format(id_from_ref(properties['parent'])),
                'relname': 'vifs',
                'id': id_from_ref(ref),
                }

        title = properties.get('device') or properties['uuid']

        return {
            'compname': 'vms/{}'.format(id_from_ref(properties.get('VM'))),
            'relname': 'vifs',
            'id': id_from_ref(ref),
            'title': title,
            'xenapi_ref': ref,
            'xenapi_metrics_ref': properties.get('metrics'),
            'xenapi_uuid': properties.get('uuid'),
            'macaddress': properties.get('MAC'),
            'mac_autogenerated': properties.get('MAC_autogenerated'),
            'mtu': properties.get('MTU'),
            'allowed_operations': properties.get('allowed_operations'),
            'currently_attached': properties.get('currently_attached'),
            'vif_device': properties.get('device'),
            'ipv4_allowed': properties.get('ipv4_allowed'),
            'ipv6_allowed': properties.get('ipv6_allowed'),
            'locking_mode': properties.get('locking_mode'),
            'setNetwork': id_from_ref(properties.get('network')),
            }

    def getNetwork(self):
        '''
        Return network id or None.

        Used by modeling.
        '''
        obj = self.network()
        if obj:
            return obj.id

    def setNetwork(self, network_id):
        '''
        Set network by id.

        Used by modeling.
        '''
        updateToOne(
            relationship=self.network,
            root=self.device(),
            type_=CLASS_NAME['Network'],
            id_=network_id)

    def xenrrd_prefix(self):
        '''
        Return prefix under which XenServer stores RRD data about this
        component.
        '''
        vm_uuid = self.vm().xenapi_uuid
        if vm_uuid and self.vif_device:
            return ('vm', vm_uuid, '_'.join(('vif', self.vif_device)))

    def getIconPath(self):
        '''
        Return URL to icon representing objects of this class.
        '''
        return '/++resource++xenserver/img/virtual-network-interface.png'

    def index_object(self, idxs=None):
        '''
        Overrides to also catalog in pifCatalog.
        '''
        super(VIF, self).index_object(idxs)
        getVIFCatalog(self.dmd).catalog_object(self, self.getPrimaryId())

    def unindex_object(self):
        '''
        Overrides to also uncatalog in pifCatalog.
        '''
        super(VIF, self).unindex_object()
        getVIFCatalog(self.dmd).uncatalog_object(self.getPrimaryId())

    def guest_interface(self):
        '''
        Return the guest interface associated with this VIF.
        '''
        if not self.vif_device:
            return

        guest_device = self.vm().guest_device()
        if guest_device:
            return guest_device.os.interfaces._getOb(
                prepId(self.vif_device), None)


class IVIFInfo(IPooledComponentInfo):
    '''
    API Info interface for VIF.
    '''

    vm = schema.Entity(title=_t(u'VM'))
    network = schema.Entity(title=_t(u'Network'))

    macaddress = schema.TextLine(title=_t(u'MAC Address'))
    mac_autogenerated = schema.TextLine(title=_t(u'Autogenerate MAC Address'))
    mtu = schema.TextLine(title=_t(u'MTU'))
    allowed_operations = schema.TextLine(title=_t(u'Allowed Operations'))
    currently_attached = schema.TextLine(title=_t(u'Currently Attached'))
    vif_device = schema.TextLine(title=_t(u'Device Name'))
    ipv4_allowed = schema.TextLine(title=_t(u'IPv4 Allowed'))
    ipv6_allowed = schema.TextLine(title=_t(u'IPv6 Allowed'))
    locking_mode = schema.TextLine(title=_t(u'Locking Mode'))


class VIFInfo(PooledComponentInfo):
    '''
    API Info adapter factory for VIF.
    '''

    implements(IVIFInfo)
    adapts(VIF)

    vm = RelationshipInfoProperty('vm')
    network = RelationshipInfoProperty('network')

    xenapi_metrics_ref = ProxyProperty('xenapi_metrics_ref')
    macaddress = ProxyProperty('macaddress')
    mac_autogenerated = ProxyProperty('mac_autogenerated')
    mtu = ProxyProperty('mtu')
    allowed_operations = ProxyProperty('allowed_operations')
    currently_attached = ProxyProperty('currently_attached')
    vif_device = ProxyProperty('vif_device')
    ipv4_allowed = ProxyProperty('ipv4_allowed')
    ipv6_allowed = ProxyProperty('ipv6_allowed')
    locking_mode = ProxyProperty('locking_mode')


class VIFPathReporter(DefaultPathReporter):
    '''
    Path reporter for VIF.
    '''

    def getPaths(self):
        paths = super(VIFPathReporter, self).getPaths()

        network = self.context.network()
        if network:
            paths.extend(relPath(network, 'endpoint'))

        vapp = self.context.vm().vmappliance()
        if vapp:
            paths.extend(relPath(vapp, 'endpoint'))

        return paths


def getVIFCatalog(dmd):
    '''
    Return the vifCatalog.

    Creates the catalog if it doesn't already exist.
    '''
    try:
        return dmd.Devices.XenServer.vifCatalog
    except AttributeError:
        return createVIFCatalog(dmd)


def createVIFCatalog(dmd):
    '''
    Create /zport/dmd/Devices/XenServer/vifCatalog and return it.

    This allows for fast lookup of VIFs by MAC address.
    '''
    from Products.ZCatalog.Catalog import CatalogError
    from Products.ZCatalog.ZCatalog import manage_addZCatalog

    from Products.ZenUtils.Search import makeCaseInsensitiveFieldIndex
    from Products.Zuul.interfaces import ICatalogTool

    catalog_name = 'vifCatalog'
    device_class = dmd.Devices.createOrganizer('/XenServer')

    if not hasattr(device_class, catalog_name):
        LOG.info('Creating VIF catalog')
        manage_addZCatalog(device_class, catalog_name, catalog_name)

    zcatalog = device_class._getOb(catalog_name)
    catalog = zcatalog._catalog

    try:
        LOG.info('Adding MAC address index to VIF catalog')
        catalog.addIndex(
            'macaddress',
            makeCaseInsensitiveFieldIndex('macaddress'))

    except CatalogError:
        # Index already exists.
        pass

    else:
        LOG.info('Reindexing all VIFs')
        vif_brains = ICatalogTool(dmd.primaryAq()).search(CLASS_NAME['VIF'])
        for vif_brain in vif_brains:
            vif_brain.getObject().index_object()

    return catalog


def findVIFByMAC(dmd, macaddresses):
    '''
    Return the first VIF matching macaddresses or None if no match.

    macaddresses can be a single MAC address string or an iterable of
    MAC address strings. It is expected to be formatted as follows.
    Where each x must be a salid hexidecimal character of any case.

        xx:xx:xx:xx:xx:xx
    '''
    if not macaddresses:
        return

    for brain in getVIFCatalog(dmd)(macaddress=macaddresses):
        return brain.getObject()
